import com.github.benmanes.gradle.versions.reporter.result.Result
import com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask
import com.vanniktech.dependency.graph.generator.DependencyGraphGeneratorExtension.Generator
import groovy.xml.MarkupBuilder
import guru.nidi.graphviz.attribute.Color
import guru.nidi.graphviz.attribute.Style
import guru.nidi.graphviz.model.MutableNode
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.ComponentSelection
import org.gradle.api.artifacts.ComponentSelectionRules
import org.gradle.api.artifacts.ResolvedDependency

plugins {
    id 'com.vanniktech.dependency.graph.generator'
    id 'com.github.ben-manes.versions'
//    se.patrikerdes.`use-latest-versions`

    id 'project-report'
}

dependencyGraphGenerator {
    generators = Arrays.asList(
        Generator.ALL,
        new Generator(
            "micronaut", // Suffix for our Gradle task.
            { ["micronaut"].any { tag -> it.moduleGroup.contains(tag) || it.moduleName.contains(tag) } },
            { true },
            { MutableNode node, ResolvedDependency _ -> node.add(Style.FILLED, Color.rgb("#6CB23F")) }
        ),
        new Generator(
            "spring", // Suffix for our Gradle task.
            { ["org.springframework"].any { tag -> it.moduleGroup.contains(tag) || it.moduleName.contains(tag) } },
            { true },
            { MutableNode node, ResolvedDependency _ -> node.add(Style.FILLED, Color.rgb("#6CB23F")) }
        ),
        new Generator(
            "javax", // Suffix for our Gradle task.
            { ["javax"].any { tag -> it.moduleGroup.contains(tag) || it.moduleName.contains(tag) } },
            { true },
            { MutableNode node, ResolvedDependency _ -> node.add(Style.FILLED, Color.rgb("#f35d45")) }
        ),
        new Generator(
            "jakarta", // Suffix for our Gradle task.
            { ["jakarta"].any { tag -> it.moduleGroup.contains(tag) || it.moduleName.contains(tag) } },
            { true },
            { MutableNode node, ResolvedDependency _ -> node.add(Style.FILLED, Color.rgb("#f35d45")) }
        ),
        new Generator(
            "javaxOrJakarta", // Suffix for our Gradle task.
            { ["javax", "jakarta", "glassfish", "com.sun", "jvnet"].any { tag -> it.moduleGroup.contains(tag) || it.moduleName.contains(tag) } },
            { true },
            { MutableNode node, ResolvedDependency _ -> node.add(Style.FILLED, Color.rgb("#f35d45")) }
        ),
        new Generator(
            "ebean", // Suffix for our Gradle task.
            { ["ebean", "avaje"].any { tag -> it.moduleGroup.contains(tag) || it.moduleName.contains(tag) } },
            { true },
            { MutableNode node, ResolvedDependency _ -> node.add(Style.FILLED, Color.rgb("#f57a1b")) }
        ),
        new Generator(
            "metrics", // Suffix for our Gradle task.
            { ["metrics", "micrometer", "actuator", "dropwizzard"].any { tag -> it.moduleGroup.contains(tag) || it.moduleName.contains(tag) } }, // Only want Metrics.
            { true },
            { MutableNode node, ResolvedDependency _ -> node.add(Style.FILLED, Color.rgb("#f57a1b")) }
        )
    )
}

tasks.dependencyUpdates {
    group = "reporting"
    resolutionStrategy {
        componentSelection {
            all {
                def rejected = false
                if (rejected) {
                    reject("We want all candidates -> none rejected")
                }
            }
        }
    }
    outputFormatter = { Result result ->
        def updatable = result.outdated.dependencies
        if (!updatable.isEmpty()) {
            def writer = new StringWriter()
            def html = new MarkupBuilder(writer)

            html.html {
                body {
                    table {
                        thead {
                            tr {
                                td("Group")
                                td("Module")
                                td("Current version")
                                td("Latest version")
                            }
                        }
                        tbody {
                            updatable.each { dependency->
                                tr {
                                    td(dependency.group)
                                    td(dependency.name)
                                    td(dependency.version)
                                    td(dependency.available.release ?: dependency.available.milestone)
                                }
                            }
                        }
                    }
                }
            }
            file("$project.buildDir/dependencyUpdates").mkdirs()
            def file = file("$project.buildDir/dependencyUpdates/report.html")
            file.createNewFile()
            file.write(writer.toString())
        }
    }
}

